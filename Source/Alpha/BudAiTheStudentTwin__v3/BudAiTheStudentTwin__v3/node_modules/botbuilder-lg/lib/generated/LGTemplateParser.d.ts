/**
 * @module botbuilder-lg
 */
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
import { ATN } from "antlr4ts/atn/ATN";
import { Parser } from "antlr4ts/Parser";
import { ParserRuleContext } from "antlr4ts/ParserRuleContext";
import { TerminalNode } from "antlr4ts/tree/TerminalNode";
import { TokenStream } from "antlr4ts/TokenStream";
import { Vocabulary } from "antlr4ts/Vocabulary";
import { LGTemplateParserListener } from "./LGTemplateParserListener";
import { LGTemplateParserVisitor } from "./LGTemplateParserVisitor";
export declare class LGTemplateParser extends Parser {
    static readonly WS = 1;
    static readonly NEWLINE = 2;
    static readonly COMMENTS = 3;
    static readonly DASH = 4;
    static readonly LEFT_SQUARE_BRACKET = 5;
    static readonly INVALID_TOKEN = 6;
    static readonly WS_IN_BODY = 7;
    static readonly MULTILINE_PREFIX = 8;
    static readonly NEWLINE_IN_BODY = 9;
    static readonly IF = 10;
    static readonly ELSEIF = 11;
    static readonly ELSE = 12;
    static readonly SWITCH = 13;
    static readonly CASE = 14;
    static readonly DEFAULT = 15;
    static readonly ESCAPE_CHARACTER = 16;
    static readonly EXPRESSION = 17;
    static readonly TEXT = 18;
    static readonly MULTILINE_SUFFIX = 19;
    static readonly WS_IN_STRUCTURE_NAME = 20;
    static readonly NEWLINE_IN_STRUCTURE_NAME = 21;
    static readonly STRUCTURE_NAME = 22;
    static readonly TEXT_IN_STRUCTURE_NAME = 23;
    static readonly STRUCTURED_COMMENTS = 24;
    static readonly WS_IN_STRUCTURE_BODY = 25;
    static readonly STRUCTURED_NEWLINE = 26;
    static readonly STRUCTURED_BODY_END = 27;
    static readonly STRUCTURE_IDENTIFIER = 28;
    static readonly STRUCTURE_EQUALS = 29;
    static readonly STRUCTURE_OR_MARK = 30;
    static readonly ESCAPE_CHARACTER_IN_STRUCTURE_BODY = 31;
    static readonly EXPRESSION_IN_STRUCTURE_BODY = 32;
    static readonly TEXT_IN_STRUCTURE_BODY = 33;
    static readonly RULE_template = 0;
    static readonly RULE_body = 1;
    static readonly RULE_structuredTemplateBody = 2;
    static readonly RULE_structuredBodyNameLine = 3;
    static readonly RULE_errorStructuredName = 4;
    static readonly RULE_structuredBodyContentLine = 5;
    static readonly RULE_errorStructureLine = 6;
    static readonly RULE_keyValueStructureLine = 7;
    static readonly RULE_keyValueStructureValue = 8;
    static readonly RULE_structuredBodyEndLine = 9;
    static readonly RULE_normalTemplateBody = 10;
    static readonly RULE_templateString = 11;
    static readonly RULE_normalTemplateString = 12;
    static readonly RULE_errorTemplateString = 13;
    static readonly RULE_ifElseTemplateBody = 14;
    static readonly RULE_ifConditionRule = 15;
    static readonly RULE_ifCondition = 16;
    static readonly RULE_switchCaseTemplateBody = 17;
    static readonly RULE_switchCaseRule = 18;
    static readonly RULE_switchCaseStat = 19;
    static readonly RULE_expression = 20;
    static readonly RULE_expressionInStructure = 21;
    static readonly ruleNames: string[];
    private static readonly _LITERAL_NAMES;
    private static readonly _SYMBOLIC_NAMES;
    static readonly VOCABULARY: Vocabulary;
    readonly vocabulary: Vocabulary;
    readonly grammarFileName: string;
    readonly ruleNames: string[];
    readonly serializedATN: string;
    constructor(input: TokenStream);
    template(): TemplateContext;
    body(): BodyContext;
    structuredTemplateBody(): StructuredTemplateBodyContext;
    structuredBodyNameLine(): StructuredBodyNameLineContext;
    errorStructuredName(): ErrorStructuredNameContext;
    structuredBodyContentLine(): StructuredBodyContentLineContext;
    errorStructureLine(): ErrorStructureLineContext;
    keyValueStructureLine(): KeyValueStructureLineContext;
    keyValueStructureValue(): KeyValueStructureValueContext;
    structuredBodyEndLine(): StructuredBodyEndLineContext;
    normalTemplateBody(): NormalTemplateBodyContext;
    templateString(): TemplateStringContext;
    normalTemplateString(): NormalTemplateStringContext;
    errorTemplateString(): ErrorTemplateStringContext;
    ifElseTemplateBody(): IfElseTemplateBodyContext;
    ifConditionRule(): IfConditionRuleContext;
    ifCondition(): IfConditionContext;
    switchCaseTemplateBody(): SwitchCaseTemplateBodyContext;
    switchCaseRule(): SwitchCaseRuleContext;
    switchCaseStat(): SwitchCaseStatContext;
    expression(): ExpressionContext;
    expressionInStructure(): ExpressionInStructureContext;
    static readonly _serializedATN: string;
    static __ATN: ATN;
    static readonly _ATN: ATN;
}
export declare class TemplateContext extends ParserRuleContext {
    body(): BodyContext;
    EOF(): TerminalNode;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    readonly ruleIndex: number;
    enterRule(listener: LGTemplateParserListener): void;
    exitRule(listener: LGTemplateParserListener): void;
    accept<Result>(visitor: LGTemplateParserVisitor<Result>): Result;
}
export declare class BodyContext extends ParserRuleContext {
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    readonly ruleIndex: number;
    copyFrom(ctx: BodyContext): void;
}
export declare class NormalBodyContext extends BodyContext {
    normalTemplateBody(): NormalTemplateBodyContext;
    constructor(ctx: BodyContext);
    enterRule(listener: LGTemplateParserListener): void;
    exitRule(listener: LGTemplateParserListener): void;
    accept<Result>(visitor: LGTemplateParserVisitor<Result>): Result;
}
export declare class IfElseBodyContext extends BodyContext {
    ifElseTemplateBody(): IfElseTemplateBodyContext;
    constructor(ctx: BodyContext);
    enterRule(listener: LGTemplateParserListener): void;
    exitRule(listener: LGTemplateParserListener): void;
    accept<Result>(visitor: LGTemplateParserVisitor<Result>): Result;
}
export declare class SwitchCaseBodyContext extends BodyContext {
    switchCaseTemplateBody(): SwitchCaseTemplateBodyContext;
    constructor(ctx: BodyContext);
    enterRule(listener: LGTemplateParserListener): void;
    exitRule(listener: LGTemplateParserListener): void;
    accept<Result>(visitor: LGTemplateParserVisitor<Result>): Result;
}
export declare class StructuredBodyContext extends BodyContext {
    structuredTemplateBody(): StructuredTemplateBodyContext;
    constructor(ctx: BodyContext);
    enterRule(listener: LGTemplateParserListener): void;
    exitRule(listener: LGTemplateParserListener): void;
    accept<Result>(visitor: LGTemplateParserVisitor<Result>): Result;
}
export declare class StructuredTemplateBodyContext extends ParserRuleContext {
    structuredBodyNameLine(): StructuredBodyNameLineContext;
    structuredBodyEndLine(): StructuredBodyEndLineContext | undefined;
    errorStructureLine(): ErrorStructureLineContext[];
    errorStructureLine(i: number): ErrorStructureLineContext;
    STRUCTURED_NEWLINE(): TerminalNode[];
    STRUCTURED_NEWLINE(i: number): TerminalNode;
    structuredBodyContentLine(): StructuredBodyContentLineContext[];
    structuredBodyContentLine(i: number): StructuredBodyContentLineContext;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    readonly ruleIndex: number;
    enterRule(listener: LGTemplateParserListener): void;
    exitRule(listener: LGTemplateParserListener): void;
    accept<Result>(visitor: LGTemplateParserVisitor<Result>): Result;
}
export declare class StructuredBodyNameLineContext extends ParserRuleContext {
    LEFT_SQUARE_BRACKET(): TerminalNode;
    STRUCTURE_NAME(): TerminalNode | undefined;
    errorStructuredName(): ErrorStructuredNameContext | undefined;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    readonly ruleIndex: number;
    enterRule(listener: LGTemplateParserListener): void;
    exitRule(listener: LGTemplateParserListener): void;
    accept<Result>(visitor: LGTemplateParserVisitor<Result>): Result;
}
export declare class ErrorStructuredNameContext extends ParserRuleContext {
    STRUCTURE_NAME(): TerminalNode[];
    STRUCTURE_NAME(i: number): TerminalNode;
    TEXT_IN_STRUCTURE_NAME(): TerminalNode[];
    TEXT_IN_STRUCTURE_NAME(i: number): TerminalNode;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    readonly ruleIndex: number;
    enterRule(listener: LGTemplateParserListener): void;
    exitRule(listener: LGTemplateParserListener): void;
    accept<Result>(visitor: LGTemplateParserVisitor<Result>): Result;
}
export declare class StructuredBodyContentLineContext extends ParserRuleContext {
    keyValueStructureLine(): KeyValueStructureLineContext | undefined;
    expressionInStructure(): ExpressionInStructureContext | undefined;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    readonly ruleIndex: number;
    enterRule(listener: LGTemplateParserListener): void;
    exitRule(listener: LGTemplateParserListener): void;
    accept<Result>(visitor: LGTemplateParserVisitor<Result>): Result;
}
export declare class ErrorStructureLineContext extends ParserRuleContext {
    STRUCTURE_IDENTIFIER(): TerminalNode[];
    STRUCTURE_IDENTIFIER(i: number): TerminalNode;
    STRUCTURE_EQUALS(): TerminalNode[];
    STRUCTURE_EQUALS(i: number): TerminalNode;
    STRUCTURE_OR_MARK(): TerminalNode[];
    STRUCTURE_OR_MARK(i: number): TerminalNode;
    TEXT_IN_STRUCTURE_BODY(): TerminalNode[];
    TEXT_IN_STRUCTURE_BODY(i: number): TerminalNode;
    expressionInStructure(): ExpressionInStructureContext[];
    expressionInStructure(i: number): ExpressionInStructureContext;
    ESCAPE_CHARACTER_IN_STRUCTURE_BODY(): TerminalNode[];
    ESCAPE_CHARACTER_IN_STRUCTURE_BODY(i: number): TerminalNode;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    readonly ruleIndex: number;
    enterRule(listener: LGTemplateParserListener): void;
    exitRule(listener: LGTemplateParserListener): void;
    accept<Result>(visitor: LGTemplateParserVisitor<Result>): Result;
}
export declare class KeyValueStructureLineContext extends ParserRuleContext {
    STRUCTURE_IDENTIFIER(): TerminalNode;
    STRUCTURE_EQUALS(): TerminalNode;
    keyValueStructureValue(): KeyValueStructureValueContext[];
    keyValueStructureValue(i: number): KeyValueStructureValueContext;
    STRUCTURE_OR_MARK(): TerminalNode[];
    STRUCTURE_OR_MARK(i: number): TerminalNode;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    readonly ruleIndex: number;
    enterRule(listener: LGTemplateParserListener): void;
    exitRule(listener: LGTemplateParserListener): void;
    accept<Result>(visitor: LGTemplateParserVisitor<Result>): Result;
}
export declare class KeyValueStructureValueContext extends ParserRuleContext {
    TEXT_IN_STRUCTURE_BODY(): TerminalNode[];
    TEXT_IN_STRUCTURE_BODY(i: number): TerminalNode;
    expressionInStructure(): ExpressionInStructureContext[];
    expressionInStructure(i: number): ExpressionInStructureContext;
    ESCAPE_CHARACTER_IN_STRUCTURE_BODY(): TerminalNode[];
    ESCAPE_CHARACTER_IN_STRUCTURE_BODY(i: number): TerminalNode;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    readonly ruleIndex: number;
    enterRule(listener: LGTemplateParserListener): void;
    exitRule(listener: LGTemplateParserListener): void;
    accept<Result>(visitor: LGTemplateParserVisitor<Result>): Result;
}
export declare class StructuredBodyEndLineContext extends ParserRuleContext {
    STRUCTURED_BODY_END(): TerminalNode;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    readonly ruleIndex: number;
    enterRule(listener: LGTemplateParserListener): void;
    exitRule(listener: LGTemplateParserListener): void;
    accept<Result>(visitor: LGTemplateParserVisitor<Result>): Result;
}
export declare class NormalTemplateBodyContext extends ParserRuleContext {
    templateString(): TemplateStringContext[];
    templateString(i: number): TemplateStringContext;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    readonly ruleIndex: number;
    enterRule(listener: LGTemplateParserListener): void;
    exitRule(listener: LGTemplateParserListener): void;
    accept<Result>(visitor: LGTemplateParserVisitor<Result>): Result;
}
export declare class TemplateStringContext extends ParserRuleContext {
    normalTemplateString(): NormalTemplateStringContext | undefined;
    errorTemplateString(): ErrorTemplateStringContext | undefined;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    readonly ruleIndex: number;
    enterRule(listener: LGTemplateParserListener): void;
    exitRule(listener: LGTemplateParserListener): void;
    accept<Result>(visitor: LGTemplateParserVisitor<Result>): Result;
}
export declare class NormalTemplateStringContext extends ParserRuleContext {
    DASH(): TerminalNode;
    MULTILINE_PREFIX(): TerminalNode | undefined;
    TEXT(): TerminalNode[];
    TEXT(i: number): TerminalNode;
    expression(): ExpressionContext[];
    expression(i: number): ExpressionContext;
    ESCAPE_CHARACTER(): TerminalNode[];
    ESCAPE_CHARACTER(i: number): TerminalNode;
    MULTILINE_SUFFIX(): TerminalNode | undefined;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    readonly ruleIndex: number;
    enterRule(listener: LGTemplateParserListener): void;
    exitRule(listener: LGTemplateParserListener): void;
    accept<Result>(visitor: LGTemplateParserVisitor<Result>): Result;
}
export declare class ErrorTemplateStringContext extends ParserRuleContext {
    INVALID_TOKEN(): TerminalNode[];
    INVALID_TOKEN(i: number): TerminalNode;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    readonly ruleIndex: number;
    enterRule(listener: LGTemplateParserListener): void;
    exitRule(listener: LGTemplateParserListener): void;
    accept<Result>(visitor: LGTemplateParserVisitor<Result>): Result;
}
export declare class IfElseTemplateBodyContext extends ParserRuleContext {
    ifConditionRule(): IfConditionRuleContext[];
    ifConditionRule(i: number): IfConditionRuleContext;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    readonly ruleIndex: number;
    enterRule(listener: LGTemplateParserListener): void;
    exitRule(listener: LGTemplateParserListener): void;
    accept<Result>(visitor: LGTemplateParserVisitor<Result>): Result;
}
export declare class IfConditionRuleContext extends ParserRuleContext {
    ifCondition(): IfConditionContext;
    normalTemplateBody(): NormalTemplateBodyContext | undefined;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    readonly ruleIndex: number;
    enterRule(listener: LGTemplateParserListener): void;
    exitRule(listener: LGTemplateParserListener): void;
    accept<Result>(visitor: LGTemplateParserVisitor<Result>): Result;
}
export declare class IfConditionContext extends ParserRuleContext {
    DASH(): TerminalNode;
    IF(): TerminalNode | undefined;
    ELSE(): TerminalNode | undefined;
    ELSEIF(): TerminalNode | undefined;
    WS(): TerminalNode[];
    WS(i: number): TerminalNode;
    TEXT(): TerminalNode[];
    TEXT(i: number): TerminalNode;
    expression(): ExpressionContext[];
    expression(i: number): ExpressionContext;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    readonly ruleIndex: number;
    enterRule(listener: LGTemplateParserListener): void;
    exitRule(listener: LGTemplateParserListener): void;
    accept<Result>(visitor: LGTemplateParserVisitor<Result>): Result;
}
export declare class SwitchCaseTemplateBodyContext extends ParserRuleContext {
    switchCaseRule(): SwitchCaseRuleContext[];
    switchCaseRule(i: number): SwitchCaseRuleContext;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    readonly ruleIndex: number;
    enterRule(listener: LGTemplateParserListener): void;
    exitRule(listener: LGTemplateParserListener): void;
    accept<Result>(visitor: LGTemplateParserVisitor<Result>): Result;
}
export declare class SwitchCaseRuleContext extends ParserRuleContext {
    switchCaseStat(): SwitchCaseStatContext;
    normalTemplateBody(): NormalTemplateBodyContext | undefined;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    readonly ruleIndex: number;
    enterRule(listener: LGTemplateParserListener): void;
    exitRule(listener: LGTemplateParserListener): void;
    accept<Result>(visitor: LGTemplateParserVisitor<Result>): Result;
}
export declare class SwitchCaseStatContext extends ParserRuleContext {
    DASH(): TerminalNode;
    SWITCH(): TerminalNode | undefined;
    CASE(): TerminalNode | undefined;
    DEFAULT(): TerminalNode | undefined;
    WS(): TerminalNode[];
    WS(i: number): TerminalNode;
    TEXT(): TerminalNode[];
    TEXT(i: number): TerminalNode;
    expression(): ExpressionContext[];
    expression(i: number): ExpressionContext;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    readonly ruleIndex: number;
    enterRule(listener: LGTemplateParserListener): void;
    exitRule(listener: LGTemplateParserListener): void;
    accept<Result>(visitor: LGTemplateParserVisitor<Result>): Result;
}
export declare class ExpressionContext extends ParserRuleContext {
    EXPRESSION(): TerminalNode;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    readonly ruleIndex: number;
    enterRule(listener: LGTemplateParserListener): void;
    exitRule(listener: LGTemplateParserListener): void;
    accept<Result>(visitor: LGTemplateParserVisitor<Result>): Result;
}
export declare class ExpressionInStructureContext extends ParserRuleContext {
    EXPRESSION_IN_STRUCTURE_BODY(): TerminalNode;
    constructor(parent: ParserRuleContext | undefined, invokingState: number);
    readonly ruleIndex: number;
    enterRule(listener: LGTemplateParserListener): void;
    exitRule(listener: LGTemplateParserListener): void;
    accept<Result>(visitor: LGTemplateParserVisitor<Result>): Result;
}
//# sourceMappingURL=LGTemplateParser.d.ts.map