"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseAuthResponseDialog = void 0;
const isEmpty_1 = __importDefault(require("lodash/isEmpty"));
const botbuilder_1 = require("botbuilder");
const adaptive_expressions_1 = require("adaptive-expressions");
const botbuilder_dialogs_1 = require("botbuilder-dialogs");
const actionHelpers_1 = require("./actionHelpers");
const baseTeamsCacheInfoResponseDialog_1 = require("./baseTeamsCacheInfoResponseDialog");
/**
 * Base type for auth response dialogs.
 */
class BaseAuthResponseDialog extends baseTeamsCacheInfoResponseDialog_1.BaseTeamsCacheInfoResponseDialog {
    getConverter(property) {
        switch (property) {
            case 'disabled':
                return new adaptive_expressions_1.BoolExpressionConverter();
            case 'property':
            case 'connectionName':
            case 'title':
                return new adaptive_expressions_1.StringExpressionConverter();
            default:
                return super.getConverter(property);
        }
    }
    /**
     * Called when the dialog is started and pushed onto the dialog stack.
     *
     * @param {DialogContext} dc The DialogContext for the turn of conversation.
     * @param {Record<string,any>} _options Optional, initial information to pass to the dialog.
     * @returns {Promise<DialogTurnResult>} Promise representing the DialogTurnResult.
     */
    beginDialog(dc, _options) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (((_a = this.disabled) === null || _a === void 0 ? void 0 : _a.getValue(dc.state)) === true) {
                return dc.endDialog();
            }
            const connectionName = (0, actionHelpers_1.getValue)(dc, this.connectionName);
            if (!connectionName) {
                throw new Error('A valid ConnectionName is required for auth responses.');
            }
            const title = (0, actionHelpers_1.getValue)(dc, this.title);
            if (!title) {
                throw new Error('A valid Title is required for auth responses.');
            }
            const tokenResponse = yield BaseAuthResponseDialog.getUserToken(dc, connectionName);
            if (tokenResponse) {
                // We have the token, so the user is already signed in.
                // Similar to OAuthInput, just return the token in the property.
                if (this.property) {
                    dc.state.setValue(this.property.getValue(dc.state), tokenResponse);
                }
                // End the dialog and return the token response.
                return dc.endDialog(tokenResponse);
            }
            // There is no token, so the user has not signed in yet.
            const activity = yield this.createOAuthInvokeResponseActivityFromTitleAndConnectionName(dc, title, connectionName);
            yield dc.context.sendActivity(activity);
            // Since the token was not retrieved above, end the turn.
            return botbuilder_dialogs_1.Dialog.EndOfTurn;
        });
    }
    createOAuthInvokeResponseActivityFromTitleAndConnectionName(dc, title, connectionName) {
        return __awaiter(this, void 0, void 0, function* () {
            const userTokenClient = dc.context.turnState.get(dc.context.adapter.UserTokenClientKey);
            if (userTokenClient) {
                const signInResource = yield userTokenClient.getSignInResource(connectionName, dc.context.activity, '');
                return this.createOAuthInvokeResponseActivityFromTitleAndSignInLink(dc, title, signInResource.signInLink);
            }
            if (!(0, actionHelpers_1.testAdapterHasAuthMethods)(dc.context.adapter)) {
                throw new Error('Auth is not supported by the current adapter.');
            }
            else if (!title || !connectionName) {
                throw new Error('title and connectionName are required.');
            }
            const signInLink = yield dc.context.adapter.getSignInLink(dc.context, connectionName);
            return this.createOAuthInvokeResponseActivityFromTitleAndSignInLink(dc, title, signInLink);
        });
    }
    createOAuthInvokeResponseActivityFromTitleAndSignInLink(dc, title, signInLink) {
        return __awaiter(this, void 0, void 0, function* () {
            const signInAction = {
                type: botbuilder_1.ActionTypes.OpenUrl,
                value: signInLink,
                title,
            };
            return this.createOAuthInvokeResponseActivityFromCardAction(dc, signInAction);
        });
    }
    static getUserToken(dc, connectionName) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            // When the Bot Service Auth flow completes, the action.State will contain a magic code used for verification.
            const state = (_a = dc.context.activity.value) === null || _a === void 0 ? void 0 : _a.state;
            const userTokenClient = dc.context.turnState.get(dc.context.adapter.UserTokenClientKey);
            if (userTokenClient) {
                return userTokenClient.getUserToken((_b = dc.context.activity.from) === null || _b === void 0 ? void 0 : _b.id, connectionName, dc.context.activity.channelId, state);
            }
            if (!(0, actionHelpers_1.testAdapterHasAuthMethods)(dc.context.adapter)) {
                throw new Error('Auth is not supported by the current adapter.');
            }
            // When the Bot Service Auth flow completes, the action.State will contain a magic code used for verification.
            const magicCode = !(0, isEmpty_1.default)(dc.context.activity.value)
                ? dc.context.activity.value.state
                : undefined;
            // TODO: SSO and skills token exchange.
            return dc.context.adapter.getUserToken(dc.context, connectionName, magicCode);
        });
    }
}
exports.BaseAuthResponseDialog = BaseAuthResponseDialog;
//# sourceMappingURL=baseAuthResponseDialog.js.map